<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux内存管理 on 悠创</title>
    <link>http://localhost:1313/Yocreative.github.io/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
    <description>Recent content in Linux内存管理 on 悠创</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Jan 2024 21:16:10 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/Yocreative.github.io/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一、内存管理的由来及思想</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E6%80%9D%E6%83%B3/</link>
      <pubDate>Wed, 17 Jan 2024 21:09:41 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E6%80%9D%E6%83%B3/</guid>
      <description>&lt;h1 id=&#34;linux内存管理--一内存管理的由来及思想&#34;&gt;&#xA;  Linux内存管理 | 一、内存管理的由来及思想&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e4%b8%80%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e7%94%b1%e6%9d%a5%e5%8f%8a%e6%80%9d%e6%83%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1前言&#34;&gt;&#xA;  1、前言&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e5%89%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;《中庸》有：“九层之台，起于垒土” 之说，那么对于我们搞技术的人，同样如此！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;对于&lt;code&gt;Linux&lt;/code&gt;内存管理，你可以说没有留意过，但是它存在于我们日常开发的方方面面，你所打开的文件，你所创建的变量，你所运行的程序，无不以此为基础，它可以说是操作系统的基石；只是底层被封装的太好了，以至于我们在做开发的过程中，不需要关心的太多，哪有什么岁月静好，只是有人在负重前行罢了。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;虽然日常开发中涉及的比较少，但是作为一个合格的&lt;code&gt;Linux&lt;/code&gt;开发者，搞懂内存管理，又显得至关重要，同时也会对嵌入式开发大有脾益，今天我们就来详细聊聊内存管理的那点事。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;该方面的文章，网上也有很多写的非常不错，但是100个人有100种理解方式，并且不同的人，基础不同，理解能力也不同，所以我写这系列的文章，也更有了意义。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;2内存管理的由来&#34;&gt;&#xA;  2、内存管理的由来&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e7%94%b1%e6%9d%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;为什么要有这个概念呢？&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;首先，内存管理，管理的是个什么东西？&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;管理的其实是我们的物理内存，也就是我们的&lt;code&gt;RAM&lt;/code&gt;空间，在电脑上，表现为我们安装的内存条，有的人装个&lt;code&gt;4G&lt;/code&gt;的、&lt;code&gt;8G&lt;/code&gt;的、甚至&lt;code&gt;64G&lt;/code&gt;的，这些就是实打实的物理空间大小，也就是我们的实际的硬件资源。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/u=3890072658,3990799507&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;为什么要进行管理？&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;做嵌入式的都知道，像我们刚开始玩的&lt;code&gt;C51&lt;/code&gt;单片机、&lt;code&gt;STM32&lt;/code&gt;单片机，我们将程序烧录到&lt;code&gt;Flash&lt;/code&gt;中后，开机启动后，然后&lt;code&gt;CPU&lt;/code&gt;会将&lt;code&gt;Flash&lt;/code&gt;程序加载到&lt;code&gt;RAM&lt;/code&gt;中，也就是我们的物理内存，随后我们的所有操作都是基于这一个物理内存所进行的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/019f1f0d2d30469cbda2b8fe2cf5e622.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;那么此时&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;我们想再次运行一个一模一样的程序怎么办？&lt;/li&gt;&#xA;&lt;li&gt;即使运行了，那两个程序同时操作了同一个变量，值被错误修改了怎么办？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这些就是&lt;code&gt;Linux&lt;/code&gt;内存管理要做的事情。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;顺便介绍一下 我的圈子：&lt;a href=&#34;https://t.zsxq.com/0eUcTOhdO&#34;&gt;高级工程师聚集地&lt;/a&gt;，期待大家的加入。&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;h2 id=&#34;3linux内存管理思想&#34;&gt;&#xA;  3、Linux内存管理思想&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%80%9d%e6%83%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;为了解决上面的一些问题，&lt;code&gt;Linux&lt;/code&gt;采用虚拟内存管理技术。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;Linux&lt;/code&gt;操作系统抽象出来一个&lt;strong&gt;虚拟地址空间&lt;/strong&gt;的概念，供上层用户使用，这么做的目的是为了让多个用户进程，都以为自己独享了内存空间。&lt;/li&gt;&#xA;&lt;li&gt;而虚拟地址空间与物理地址空间的对应关系，就交给了一个&lt;code&gt;MMU(Memory Managerment Unit)&lt;/code&gt;的家伙来管理，其主要负责将虚拟内存空间映射到真实的物理地址空间。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/72ab76ba697e470b8ceb14d5fc5688d9.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;这么做的主要目的在于：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;让每个进程都拥有相同大小的虚拟地址空间&lt;/li&gt;&#xA;&lt;li&gt;避免用户直接访问物理内存，导致系统崩溃&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这样，我们同时执行多个进程，虽然看起来虚拟地址操作都是相同的，但是通过&lt;code&gt;MMU&lt;/code&gt;之后，就被映射到了不同的物理地址空间，这样就解决了以上的问题。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;4总结&#34;&gt;&#xA;  4、总结&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;熟悉了内存管理由来以及其思想，我们可以看出，操作系统的内存管理，主要分为以下几个方面：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟内存空间管理&lt;/strong&gt;：我们抽象出来的虚拟地址空间，该怎么使用，该怎么管理？&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;物理内存空间管理&lt;/strong&gt;：虚拟地址映射到物理内存空间后，该如何管理，如何分配？&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;如何映射&lt;/strong&gt;：虚拟内存如何映射到物理内存，是怎么操作的，映射方法有哪些？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;下面我们来一一详细探究。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;center&gt;&lt;b&gt; &lt;font color =&#34;blue&#34;&gt;欢迎关注【嵌入式艺术】，董哥原创！&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;&#xA;&lt;div align=center&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/blog.png&#34; alt=&#34;img&#34; width = &#34;60%&#34; height =&#34;10%&#34;/&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>二、虚拟地址空间布局</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 17 Jan 2024 21:13:17 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/</guid>
      <description>&lt;h1 id=&#34;linux内存管理--二虚拟地址空间布局&#34;&gt;&#xA;  Linux内存管理 | 二、虚拟地址空间布局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e4%ba%8c%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;上一章，我们了解了内存管理的由来以及核心思想，下面我们按照顺序，先来介绍一下&lt;code&gt;Linux&lt;/code&gt;虚拟内存空间的管理。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;同样，我们知道&lt;code&gt;Linux&lt;/code&gt;内核抽象出来虚拟内存空间，主要是为了让每个进程都独享该空间，那虚拟内存空间是如何布局的呢？&lt;/p&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;：针对于不同位数的&lt;code&gt;CPU&lt;/code&gt;，寻址能力不同，抽象出来的虚拟内存空间大小也不同，我们以常见的&lt;code&gt;32&lt;/code&gt;位的&lt;code&gt;CPU&lt;/code&gt;为例。&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;1虚拟内存空间布局&#34;&gt;&#xA;  1、虚拟内存空间布局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;对于&lt;code&gt;32&lt;/code&gt;位的&lt;code&gt;CPU&lt;/code&gt;，寻址范围为&lt;code&gt;0~2^32&lt;/code&gt;，也就是&lt;code&gt;0x00000000-0xFFFFFFFF&lt;/code&gt;，即最多抽象出来&lt;code&gt;4G&lt;/code&gt;的虚拟内存空间。&lt;/p&gt;&#xA;&lt;p&gt;这&lt;code&gt;4GB&lt;/code&gt;的内存空间，在&lt;code&gt;Linux&lt;/code&gt;中，又分为&lt;strong&gt;用户空间和内核空间&lt;/strong&gt;，其中&lt;code&gt;0x0000000-0xBFFFFFFF&lt;/code&gt;，共&lt;code&gt;3G&lt;/code&gt;为用户空间，&lt;code&gt;0xC00000000-0xFFFFFFFF&lt;/code&gt;，共&lt;code&gt;1G&lt;/code&gt;为内核空间，如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20230924173124939.png&#34; alt=&#34;image-20230924173124939&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;无论内核空间还是用户空间，其仍然是在虚拟内存空间基础之上进行划分的，其直接访问的依旧都是虚拟地址，而非物理地址！&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们编写代码后，所生成的可执行程序，运行之后就成为一个系统进程，我们在&amp;quot;虚&amp;quot;的角度来看，每个进程都是独享这&lt;code&gt;4G&lt;/code&gt;虚拟地址空间的，&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;2用户态空间布局&#34;&gt;&#xA;  2、用户态空间布局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2%e7%94%a8%e6%88%b7%e6%80%81%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;如上所述，用户空间在虚拟内存中分布在&lt;code&gt;0x0000000-0xBFFFFFFF&lt;/code&gt;，大小为&lt;code&gt;3G&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;每一个用户进程，按照&lt;strong&gt;访问属性一致的地址空间存放在一起&lt;/strong&gt;的原则，划分成5个不同的内存区域（访问属性一致指的是：可读，可写，可执行）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;代码段&lt;/strong&gt;：&lt;code&gt;Text Segment&lt;/code&gt;，也就是我们的二进制程序，代码段需要防止在运行时被非法修改，&lt;strong&gt;所以该段为只读&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据段&lt;/strong&gt;：&lt;code&gt;Data Segment&lt;/code&gt;，主要存放初始化了的变量，主要包括：静态变量和全局变量，&lt;strong&gt;该段为读写&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;BSS&lt;/code&gt;段&lt;/strong&gt;：&lt;code&gt;BSS Segment&lt;/code&gt;，主要存放未初始化的全局变量，在内存中 &lt;code&gt;bss&lt;/code&gt; 段全部置零，&lt;strong&gt;该段为读写&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;堆段&lt;/strong&gt;：&lt;code&gt;Heap Segment&lt;/code&gt;，主要存放进程运行过程中动态分配的内存段，大小不固定，可动态扩张和缩减，通常使用&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;来分配释放，并且堆的增长方向是向上的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;文件映射和匿名映射段&lt;/strong&gt;：&lt;code&gt;Memory Mapping Segment&lt;/code&gt;，主要存放进程使用到的文件或者依赖的动态库，从低地址向上增长。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;栈段&lt;/strong&gt;：&lt;code&gt;Stack Segment&lt;/code&gt;，主要存放进程临时创建的局部变量，函数调用上下文信息等，栈向下增长。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231005160139650.png&#34; alt=&#34;image-20231005160139650&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;一个可执行程序，可以通过&lt;code&gt;size&lt;/code&gt;命令，查看编译出来的可执行文件大小，其中包括了代码段，数据段等数据信息，如下:&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;donge@Donge:$ size Donge-Demo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   text    data     bss     dec     hex filename&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#bd93f9&#34;&gt;12538&lt;/span&gt;    &lt;span style=&#34;color:#bd93f9&#34;&gt;1916&lt;/span&gt;   &lt;span style=&#34;color:#bd93f9&#34;&gt;43632&lt;/span&gt;   &lt;span style=&#34;color:#bd93f9&#34;&gt;58086&lt;/span&gt;    e2e6 Donge-Demo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;text&lt;/code&gt;：代码段大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：数据段大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;bss&lt;/code&gt;：&lt;code&gt;bss&lt;/code&gt;段大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;dec&lt;/code&gt;：十进制表示的可执行文件大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;hex&lt;/code&gt;：十六进制表示的可执行文件大小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;运行该程序后，可以通过&lt;code&gt;cat /proc/PID/maps&lt;/code&gt;命令，或者&lt;code&gt;pmap PID&lt;/code&gt;命令，来查看该进程在虚拟内存空间中的分配情况，其中PID为进程的PID号，如下:&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>三、虚拟地址空间管理</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%B8%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 17 Jan 2024 21:15:35 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%B8%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;linux内存管理--三虚拟地址空间管理&#34;&gt;&#xA;  Linux内存管理 | 三、虚拟地址空间管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e4%b8%89%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;上一节，我们主要了解了虚拟内存空间的布局情况，趁热打铁，我们直接从源代码的视角，来看一下&lt;code&gt;Linux&lt;/code&gt;内核是如何管理虚拟内存空间的。&lt;/p&gt;&#xA;&lt;p&gt;废话不多说，直接开始！&lt;/p&gt;&#xA;&lt;h2 id=&#34;1用户态空间管理&#34;&gt;&#xA;  1、用户态空间管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e7%94%a8%e6%88%b7%e6%80%81%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;读完上一节我们知道，用户态的布局情况如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231005160139650.png&#34; alt=&#34;image-20231005160139650&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们运行的可执行程序，被加载进内存后，会作为一个进程存在，这个进程&lt;code&gt;Linux&lt;/code&gt;内核会将其抽象成一个结构体。没错，它就是&lt;code&gt;task_struct&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-task_struct结构体&#34;&gt;&#xA;  1.1 task_struct结构体&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#11-task_struct%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt;结构体是进程的抽象，进程所涉及到的内容非常多，下面只列举出一些重要的数据结构，方面理解。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// include/linux/sched.h&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; task_struct {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;pid_t&lt;/span&gt;&#x9;&#x9;&#x9;&#x9;pid;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;//&#x9;进程PID&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;pid_t&lt;/span&gt;&#x9;&#x9;&#x9;&#x9;tgid;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;//&#x9;线程PID&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; files_struct&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;files;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;//  进程打开的文件信息&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; mm_struct&#x9;&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;mm;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;//&#x9;进程虚拟内存空间的内存描述符&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;如上，进程抽象为&lt;code&gt;task_struct&lt;/code&gt;结构体，通过&lt;code&gt;mm_struct&lt;/code&gt;结构体来管理虚拟内存空间。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-mm_struct结构体&#34;&gt;&#xA;  1.2 mm_struct结构体&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#12-mm_struct%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;每个进程都有唯一的 &lt;code&gt;mm_struct&lt;/code&gt; 结构体，也就是前边提到的每个进程的虚拟地址空间都是独立，互不干扰的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;mm_struct&lt;/code&gt;的结构体如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//&#x9;include/linux/mm_types.h&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; mm_struct {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; task_size;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* size of task vm space */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; mmap_base;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* base of mmap area */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; total_vm;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* Total pages mapped */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; locked_vm;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* Pages that have PG_mlocked set */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; pinned_vm;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* Refcount permanently increased */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; data_vm;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* VM_WRITE &amp;amp; ~VM_SHARED &amp;amp; ~VM_STACK */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; exec_vm;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* VM_EXEC &amp;amp; ~VM_WRITE &amp;amp; ~VM_STACK */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; stack_vm;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* VM_STACK */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; start_code, end_code, start_data, end_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; start_brk, brk, start_stack;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; arg_start, arg_end, env_start, env_end;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; vm_area_struct &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;mmap;&#x9;&#x9;&lt;span style=&#34;color:#6272a4&#34;&gt;/* list of VMAs */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; rb_root mm_rb;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }__randomize_layout;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>四、物理地址空间设计模型</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E5%9B%9B%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 17 Jan 2024 21:15:48 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E5%9B%9B%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;linux内存管理--四物理地址空间设计模型&#34;&gt;&#xA;  Linux内存管理 | 四、物理地址空间设计模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e5%9b%9b%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;前面几篇文章，主要讲解了虚拟内存空间的布局和管理，下面同步来聊聊物理内存空间的布局和管理。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;1物理内存&#34;&gt;&#xA;  1、物理内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;什么是物理内存？&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;我们平时聊的内存，也叫随机访问存储器&lt;code&gt;（random-access memory）&lt;/code&gt;，也叫&lt;code&gt;RAM&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;RAM&lt;/code&gt;分为两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SRAM&lt;/code&gt;：静态&lt;code&gt;RAM&lt;/code&gt;，其主要用于&lt;code&gt;CPU&lt;/code&gt;高速缓存 &lt;code&gt;L1Cache&lt;/code&gt;，&lt;code&gt;L2Cache&lt;/code&gt;，&lt;code&gt;L3Cache&lt;/code&gt;，其特点是访问速度快，访问速度为 1 - 30 个时钟周期，但是容量小，造价高。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/560cee15346204f216f8b144a6c2a18c.png&#34; alt=&#34;CPU缓存结构.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;DRAM&lt;/code&gt;：动态&lt;code&gt;RAM&lt;/code&gt;，其主要用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为 50 - 200 个时钟周期，但是容量大，造价便宜些（相对高速缓存）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/647cd97d53cb7d2a67067c90996fa4e8.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;DRAM&lt;/code&gt;经过组合起来，就作为我们的计算机内存，也是物理内存。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;2物理内存访问模型&#34;&gt;&#xA;  2、物理内存访问模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;上面介绍了物理内存的基本组成，那么&lt;code&gt;CPU&lt;/code&gt;是如何访问物理内存的呢？&lt;/p&gt;&#xA;&lt;p&gt;对于&lt;code&gt;CPU&lt;/code&gt;访问物理内存，&lt;code&gt;Linux&lt;/code&gt;提供了两种架构：&lt;code&gt;UMA(Uniform Memory Access)&lt;/code&gt;一致内存访问，&lt;code&gt;NUMA(Non-Uniform Memory Access)&lt;/code&gt;非一致内存访问。&lt;/p&gt;&#xA;&lt;h3 id=&#34;21-uma&#34;&gt;&#xA;  2.1 UMA&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#21-uma&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;在&lt;code&gt;UMA&lt;/code&gt;架构下，多核处理器中的多个&lt;code&gt;CPU&lt;/code&gt;，位于总线的一侧，所有的内存条组成的物理内存位于总线的另一侧。&lt;/p&gt;&#xA;&lt;p&gt;所有的&lt;code&gt;CPU&lt;/code&gt;访问内存都要经过总线，并且距离都是一样的，所以在&lt;code&gt;UMA&lt;/code&gt;架构下，&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;所有&lt;code&gt;CPU&lt;/code&gt;具有相同的访问特性，即对内存的访问具有相同的速度。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231013075142500.png&#34; alt=&#34;image-20231013075142500&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-numa&#34;&gt;&#xA;  2.2 NUMA&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#22-numa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;这种架构，系统中的&lt;strong&gt;各个处理器都有本地内存&lt;/strong&gt;，处理器与处理器之间也通过总线连接，以便于其他处理器对本地内存的访问。&lt;/p&gt;&#xA;&lt;p&gt;&lt;font color = &#34;red&#34;&gt;&lt;strong&gt;与&lt;code&gt;UMA&lt;/code&gt;不同的是，处理器访问本地内存的速度要快于对其他处理器本地内存的访问。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231013074823586.png&#34; alt=&#34;image-20231013074823586&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;3物理内存组织模型&#34;&gt;&#xA;  3、物理内存组织模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e7%bb%84%e7%bb%87%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;内存页是物理内存管理中最小单位，有时也成为页帧&lt;code&gt;（Page Frame）&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;内核对物理内存划分为一页一页的连续的内存块，每页大小&lt;code&gt;4KB&lt;/code&gt;，并且使用&lt;code&gt;struct page&lt;/code&gt;结构体来表示页结构，其中封装了每个页的状态信息，包括：组织结构，使用信息，统计信息等。&lt;/p&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;&lt;code&gt;page&lt;/code&gt;结构体较为复杂，我们后续再深入了解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>五、物理内存空间布局及管理</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%BA%94%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%8F%8A%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 17 Jan 2024 21:16:00 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E4%BA%94%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%8F%8A%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;linux内存管理--五物理内存空间布局及管理&#34;&gt;&#xA;  Linux内存管理 | 五、物理内存空间布局及管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e4%ba%94%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80%e5%8f%8a%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;上章，我们介绍了物理内存的访问内存模型和组织内存模型，我们再来回顾一下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;物理内存的访问内存模型分为&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;UMA&lt;/code&gt;：一致内存访问&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;NUMA&lt;/code&gt;：非一致内存访问&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;物理内存的组织模型&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;FLATMEM&lt;/code&gt;：平坦内存模型&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DISCONTIGMEM&lt;/code&gt;：不连续内存模型&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SMARSEMEM&lt;/code&gt;：稀疏内存模型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;内核为了用统一的代码获取最大程度的兼容性，对物理内存的定义方面，引入了：内存结点&lt;code&gt;（node）&lt;/code&gt;、内存区域&lt;code&gt;（zone）&lt;/code&gt;，内存页&lt;code&gt;（page）&lt;/code&gt;的概念，下面我们来一一探究。&lt;/p&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;更多干货可见：&lt;a href=&#34;https://t.zsxq.com/0eUcTOhdO&#34;&gt;高级工程师聚集地&lt;/a&gt;，助力大家更上一层楼！&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;1内存节点node&#34;&gt;&#xA;  1、内存节点node&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e5%86%85%e5%ad%98%e8%8a%82%e7%82%b9node&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;内存节点的引入，是&lt;code&gt;Linux&lt;/code&gt;为了最大程度的提高兼容性，将&lt;code&gt;UMA&lt;/code&gt;和&lt;code&gt;NUMA&lt;/code&gt;系统统一起来，对于&lt;code&gt;UMA&lt;/code&gt;而言是只有一个节点的系统&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;下面的代码部分，我们尽可能的只保留暂时用的到的部分，不涉及太多的体系架相关的细节。&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;在&lt;code&gt;Linux&lt;/code&gt;内核中，我们使用 &lt;code&gt;typedef struct pglist_data pg_data_t&lt;/code&gt;表示一个节点&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * On NUMA machines, each NUMA node would have a pg_data_t to describe&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * it&amp;#39;s memory layout. On UMA machines there is a single pglist_data which&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * describes the whole memory.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * Memory statistics and page replacement data structures are maintained on a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * per-zone basis.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; pglist_data {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; node_id;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;node_mem_map;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; node_start_pfn;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; node_present_pages; &lt;span style=&#34;color:#6272a4&#34;&gt;/* total number of physical pages */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;long&lt;/span&gt; node_spanned_pages; &lt;span style=&#34;color:#6272a4&#34;&gt;/* total size of physical page&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;                         range, including holes */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#8be9fd&#34;&gt;pg_data_t&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;node_id&lt;/code&gt;：每个节点都有自己的&lt;code&gt;ID&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>六、物理内存分配——伙伴系统</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 17 Jan 2024 21:16:10 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/linux/linux_memory_manage/%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;linux内存管理--六物理内存分配伙伴系统&#34;&gt;&#xA;  Linux内存管理 | 六、物理内存分配——伙伴系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e5%85%ad%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%bc%99%e4%bc%b4%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;上一章，我们了解了物理内存的布局以及&lt;code&gt;Linux&lt;/code&gt;内核对其的管理方式，页&lt;code&gt;（page）&lt;/code&gt;也是物理内存的最小单元，&lt;code&gt;Linux&lt;/code&gt;内核对物理内存的分配主要分为两种：一种是整页的分配，采用的是伙伴系统，另一种是小内存块的分配，采用的是&lt;code&gt;slab&lt;/code&gt;技术。&lt;/p&gt;&#xA;&lt;p&gt;下面我们先来看看什么是伙伴系统！&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;1伙伴系统buddy-system&#34;&gt;&#xA;  1、伙伴系统（Buddy System）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e4%bc%99%e4%bc%b4%e7%b3%bb%e7%bb%9fbuddy-system&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;系统中，对物理内存进行分配的核心是&lt;strong&gt;建立在页面级的伙伴系统之上&lt;/strong&gt;。&lt;code&gt;Linux&lt;/code&gt;内存管理的页大小为&lt;code&gt;4KB&lt;/code&gt;，把所有的空闲页分组为11个页块链表，每个链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块，最大可以申请 1024 个连续页，对应 &lt;code&gt;4MB&lt;/code&gt; 大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。&lt;/p&gt;&#xA;&lt;p&gt;如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231021143420253.png&#34; alt=&#34;image-20231021143420253&#34; /&gt;&lt;/p&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;第 i 个页块链表中，页块中页的数目为 2^i。——仔细理解这个页块的含义。&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;在&lt;code&gt;struct zone&lt;/code&gt;结构体中，有下面定义&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; free_area&#x9;free_area[MAX_ORDER];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#define MAX_ORDER 11&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;free_area&lt;/code&gt;：存放不同大小的页块&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;MAX_ORDER&lt;/code&gt;：就是指数&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;当向内核请求分配 (2^(i-1)，2^i] 数目的页块时，按照 2^i 页块请求处理。如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。&lt;/p&gt;&#xA;&lt;p&gt;举个例子：&lt;/p&gt;&#xA;&lt;p&gt;例如，要请求一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;上面的这套机制就是伙伴系统所做的事情，它主要负责对物理内存页面进行跟踪，记录哪些是被内核使用的页面，哪些是空闲页面。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;2页面分配器page-allocator&#34;&gt;&#xA;  2、页面分配器（Page Allocator）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2%e9%a1%b5%e9%9d%a2%e5%88%86%e9%85%8d%e5%99%a8page-allocator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;由上一章我们知道，物理内存被分为了几个区域：&lt;code&gt;ZONE_DMA&lt;/code&gt;、&lt;code&gt;ZONE_NORMAL&lt;/code&gt;、&lt;code&gt;ZONE_HIGHMEM&lt;/code&gt;，其中前两个区域的物理页面与虚拟地址空间是线性映射的。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
