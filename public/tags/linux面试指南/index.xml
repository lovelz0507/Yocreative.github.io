<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux面试指南 on 悠创</title>
    <link>http://localhost:1313/Yocreative.github.io/tags/linux%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</link>
    <description>Recent content in Linux面试指南 on 悠创</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Jan 2024 21:41:10 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/Yocreative.github.io/tags/linux%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Soc的Bring Up流程</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 12 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;1bring-up流程&#34;&gt;&#xA;  1、Bring Up流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1bring-up%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img2.baidu.com/it/u=1228692277,1647023594&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=PNG?w=681&amp;amp;h=294&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;SOC (System on a Chip) bring-up&lt;/code&gt;是一个复杂的过程，涉及到硬件、固件和软件的集成和验证，以下是一个基于&lt;code&gt;BROM&lt;/code&gt;，&lt;code&gt;SPL&lt;/code&gt;，&lt;code&gt;UBOOT&lt;/code&gt;和&lt;code&gt;Linux&lt;/code&gt;的启动流程的概述：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;BROM (Boot Read-Only Memory)&lt;/code&gt;启动&lt;/strong&gt;：启动的最初阶段，在这个阶段，系统会执行芯片&lt;code&gt;ROM&lt;/code&gt;里面的代码，这部分代码主要用来检查启动模式，包括&lt;code&gt;NOR&lt;/code&gt;、&lt;code&gt;Nand&lt;/code&gt;、&lt;code&gt;Emmc&lt;/code&gt;等，然后从对应的存储介质中加载&lt;code&gt;SPL(Secondary Program Loader)&lt;/code&gt;代码。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;SPL (Secondary Program Loader)&lt;/code&gt;启动&lt;/strong&gt;：&lt;code&gt;SPL&lt;/code&gt;属于&lt;code&gt;Uboot&lt;/code&gt;的一部分，它的主要作用就是：&lt;strong&gt;初始化硬件并加载完整的&lt;code&gt;U-boot&lt;/code&gt;&lt;/strong&gt;，主要体现在初始化时钟、看门狗、&lt;code&gt;DDR&lt;/code&gt;、&lt;code&gt;GPIO&lt;/code&gt;以及存储外设，最后将&lt;code&gt;U-boot&lt;/code&gt;代码加载到&lt;code&gt;DDR&lt;/code&gt;中执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;U-Boot&lt;/code&gt;启动&lt;/strong&gt;：&lt;code&gt;U-boot&lt;/code&gt;的主要作用是：引导加载&lt;code&gt;Kernel&lt;/code&gt;和&lt;code&gt;DTS&lt;/code&gt;。&lt;code&gt;U-boot&lt;/code&gt;在启动之后，同样初始化&lt;code&gt;Soc&lt;/code&gt;硬件资源，然后会计时等待，并执行默认的启动命令，将&lt;code&gt;Kernel&lt;/code&gt;和&lt;code&gt;DTS&lt;/code&gt;信息从存储介质中读取出来并加载到内存中执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Kernel&lt;/code&gt;启动&lt;/strong&gt;：在&lt;code&gt;U-Boot&lt;/code&gt;加载了内核映像和设备树之后，系统会启动&lt;code&gt;Linux&lt;/code&gt;。在这个阶段，系统会初始化各种硬件设备，加载驱动程序并启动用户空间应用程序。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;更多干货可见：&lt;a href=&#34;https://t.zsxq.com/0eUcTOhdO&#34;&gt;高级工程师聚集地&lt;/a&gt;，助力大家更上一层楼！&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;2常见问题&#34;&gt;&#xA;  2、常见问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img1.baidu.com/it/u=1356081243,31945078&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=852&amp;amp;h=500&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Q&lt;/code&gt;：为什么上一个阶段已经初始化了硬件资源，下一个阶段为何重复初始化？&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;A&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每个阶段的硬件初始化，其目标和需求都不同，硬件配置也会不一样，因此在不同阶段进行不同的初始化。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;硬件状态可能会改变，在&lt;code&gt;SOC&lt;/code&gt;启动过程中，硬件状态可能会因为电源管理、时钟管理等原因而改变，这可能需要在每个阶段都重新初始化以确保其正确工作&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为了保证硬件资源的可靠性，最好每个阶段都重新初始化一次&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Q&lt;/code&gt;：&lt;code&gt;U-boot&lt;/code&gt;加载内核时，会进行重定位的操作，这一操作有何意义？&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;A&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;U-boot&lt;/code&gt;的重定位，主要作用是为了 &lt;strong&gt;给内核提供一个连续的、大的内存空间，供内核和其他应用程序使用&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;U-boot&lt;/code&gt;的加载过程分两个阶段，即：&lt;code&gt;SPL&lt;/code&gt;和&lt;code&gt;U-boot&lt;/code&gt;，&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在&lt;code&gt;SPL&lt;/code&gt;阶段，主要将&lt;code&gt;U-boot&lt;/code&gt;代码从&lt;code&gt;Flash&lt;/code&gt;中加载到&lt;code&gt;RAM&lt;/code&gt;指定位置&lt;/li&gt;&#xA;&lt;li&gt;在&lt;code&gt;U-boot&lt;/code&gt;阶段，&lt;code&gt;U-boot&lt;/code&gt;会将自身从&lt;code&gt;RAM&lt;/code&gt;的开始部分移动到&lt;code&gt;RAM&lt;/code&gt;的末尾，占用高地址空间，从而让低地址空间可以作为一个连续的，大的内存空间供内核和其他应用程序使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Q&lt;/code&gt;：在&lt;code&gt;Bring Up&lt;/code&gt;中，为了保证启动时间，如何裁剪？&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;A&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;启动时间的裁剪是一个重要的步骤，其主要目标是缩短从电源打开到操作系统完全启动的时间。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;优化&lt;code&gt;Bootloader&lt;/code&gt;：减小&lt;code&gt;Bootloader&lt;/code&gt;的代码大小，减少硬件初始化（只初始化必要硬件设备）等&lt;/li&gt;&#xA;&lt;li&gt;优化&lt;code&gt;Kernel&lt;/code&gt;：减少启动服务数量，优化服务的启动顺序，使用预加载技术等方法来实现。&lt;/li&gt;&#xA;&lt;li&gt;使用快速启动模式：一些&lt;code&gt;SOC&lt;/code&gt;支持快速启动模式，这种模式下，&lt;code&gt;SOC&lt;/code&gt;会跳过一些不必要的硬件初始化和自检过程，从而更快地启动。&lt;/li&gt;&#xA;&lt;li&gt;使用休眠和唤醒技术：一些&lt;code&gt;SOC&lt;/code&gt;还支持休眠和唤醒技术，这种技术可以将系统的状态保存到非易失性存储器中，然后关闭系统。当系统再次启动时，可以直接从非易失性存储器中恢复系统的状态，从而更快地启动。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div align=center&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/blog.png&#34; alt=&#34;img&#34; width = &#34;60%&#34; height =&#34;10%&#34;/&gt;&#xD;&#xA;&lt;/div&gt;&#xD;&#xA;&amp;nbsp;</description>
    </item>
    <item>
      <title>CPU体系架构</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/embeded_tech/embeded_interview/cpu%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 17 Jan 2024 21:39:15 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/embeded_tech/embeded_interview/cpu%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;cpu体系架构&#34;&gt;&#xA;  CPU体系架构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu%e4%bd%93%e7%b3%bb%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img2.baidu.com/it/u=1963592699,3653391242&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=853&amp;amp;h=363&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;21-cpu体系架构有哪些&#34;&gt;&#xA;  2.1 CPU体系架构有哪些？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#21-cpu%e4%bd%93%e7%b3%bb%e6%9e%b6%e6%9e%84%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我们常见的&lt;code&gt;CPU&lt;/code&gt;架构有哪些呢？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;如果我们熟悉&lt;code&gt;Linux&lt;/code&gt;，那么这个问题肯定不难回答！&lt;/p&gt;&#xA;&lt;p&gt;我们查看内核目录下的&lt;code&gt;arch&lt;/code&gt;子目录，就可以看到&lt;code&gt;Linux&lt;/code&gt;所支持的处理器架构，基本属于我们常见的类型了。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;# ls ./arch&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;alpha  arc  arm  arm64  c6x  h8300  hexagon  ia64  Kconfig  m68k  microblaze  mips  nds32  nios2  openrisc  parisc  powerpc  riscv  s390  sh  sparc  um  unicore32  x86  xtensa&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;准确来说，&lt;code&gt;CPU&lt;/code&gt;处理器架构主要有以下几种类型&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;CISC（复杂指令集计算机）&lt;/strong&gt;：&lt;code&gt;CISC&lt;/code&gt;架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是尽可能减少程序指令的数量，以降低&lt;code&gt;CPU&lt;/code&gt;和内存之间的通信频率。这种架构的一个显著特点是拥有大量的寄存器和复杂的指令集。&lt;code&gt;Intel&lt;/code&gt;的&lt;code&gt;x86&lt;/code&gt;架构就是一个典型的&lt;code&gt;CISC&lt;/code&gt;架构&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RISC（精简指令集计算机）&lt;/strong&gt;：&lt;code&gt;RISC&lt;/code&gt;架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是通过简化指令集来提高&lt;code&gt;CPU&lt;/code&gt;的运行效率。这种架构的一个显著特点是拥有较少的寄存器和简单的指令集。&lt;code&gt;ARM&lt;/code&gt;架构就是一个典型的&lt;code&gt;RISC&lt;/code&gt;架构&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;MISC（中间指令集计算机）&lt;/strong&gt;：&lt;code&gt;MISC&lt;/code&gt;架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是在&lt;code&gt;CISC&lt;/code&gt;和&lt;code&gt;RISC&lt;/code&gt;之间寻找一个平衡点，既不过于复杂也不过于简单。这种架构的一个显著特点是指令集的复杂度介于&lt;code&gt;CISC&lt;/code&gt;和&lt;code&gt;RISC&lt;/code&gt;之间&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VLIW（超长指令字计算机）&lt;/strong&gt;：&lt;code&gt;VLIW&lt;/code&gt;架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是通过增大指令长度来提高并行执行的可能性。这种架构的一个显著特点是指令长度远大于其他架构的&lt;code&gt;CPU&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;EPIC（显式并行指令计算）&lt;/strong&gt;：&lt;code&gt;EPIC&lt;/code&gt;架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是通过显式标记并行指令来提高&lt;code&gt;CPU&lt;/code&gt;的运行效率。这种架构的一个显著特点是指令集中包含了并行执行的信息。&lt;code&gt;Intel&lt;/code&gt;的&lt;code&gt;Itanium&lt;/code&gt;架构就是一个典型的&lt;code&gt;EPIC&lt;/code&gt;架构&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;超标量架构&lt;/strong&gt;：超标量架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是通过在一个时钟周期内执行多条指令来提高&lt;code&gt;CPU&lt;/code&gt;的运行效率。这种架构的一个显著特点是&lt;code&gt;CPU&lt;/code&gt;内部包含了多个执行单元，可以同时执行多条指令&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;超线程技术&lt;/strong&gt;：超线程技术是&lt;code&gt;Intel&lt;/code&gt;公司为其部分&lt;code&gt;CPU&lt;/code&gt;所采用的一种使单一处理器像多个逻辑处理器那样并行处理多个线程的技术&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;多核心架构&lt;/strong&gt;：多核心架构的&lt;code&gt;CPU&lt;/code&gt;设计理念是在一个&lt;code&gt;CPU&lt;/code&gt;芯片内集成多个处理器核心，以提高并行处理能力。这种架构的一个显著特点是&lt;code&gt;CPU&lt;/code&gt;内部包含了多个独立的处理器核心，每个核心可以独立执行指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img2.baidu.com/it/u=3770652576,1376693706&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=120&amp;amp;f=JPEG?w=909&amp;amp;h=500&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里就有一个疑问，我们什么时候说&lt;code&gt;RISC&lt;/code&gt;架构，什么时候说&lt;code&gt;ARM&lt;/code&gt;架构，这两个有什么区别呢？&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;以&lt;code&gt;ARM&lt;/code&gt;和&lt;code&gt;RISC&lt;/code&gt;为例：&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;ARM&lt;/code&gt;架构和&lt;code&gt;RISC&lt;/code&gt;架构的主要区别在于&lt;code&gt;ARM&lt;/code&gt;实际上是&lt;code&gt;RISC&lt;/code&gt;的一个具体实现，而&lt;code&gt;RISC&lt;/code&gt;则是一个更广泛的处理器&lt;strong&gt;设计理念&lt;/strong&gt;。换句话说，&lt;code&gt;ARM&lt;/code&gt;是&lt;code&gt;RISC&lt;/code&gt;的一个子集。&lt;/p&gt;&#xA;&lt;p&gt;同理，&lt;code&gt;X86&lt;/code&gt;架构是&lt;code&gt;CISC&lt;/code&gt;的一个子集。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h2 id=&#34;22-常见的问题&#34;&gt;&#xA;  2.2 常见的问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#22-%e5%b8%b8%e8%a7%81%e7%9a%84%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Q1&lt;/code&gt;：你所熟知的处理器架构有哪些？&lt;/p&gt;&#xA;&lt;p&gt;我们常见的处理器架构有&lt;code&gt;ARM&lt;/code&gt;、&lt;code&gt;X86&lt;/code&gt;、&lt;code&gt;mips&lt;/code&gt;架构等；&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Q2&lt;/code&gt;：&lt;code&gt;STM32&lt;/code&gt;属于什么架构的？&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;STM32&lt;/code&gt;是&lt;code&gt;ST&lt;/code&gt;公司开发的32位微控制器集成电路，基于 &lt;code&gt;ARM&lt;/code&gt; 的 &lt;code&gt;Cortex-M&lt;/code&gt; 系列内核。因此，&lt;code&gt;STM32&lt;/code&gt; 属于 &lt;code&gt;ARM&lt;/code&gt; 架构的微控制器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux用户态和内核态交互的几种方式</title>
      <link>http://localhost:1313/Yocreative.github.io/docs/embeded_tech/embeded_interview/linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 17 Jan 2024 21:41:10 +0800</pubDate>
      <guid>http://localhost:1313/Yocreative.github.io/docs/embeded_tech/embeded_interview/linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;linux用户态和内核态交互的几种方式&#34;&gt;&#xA;  Linux用户态和内核态交互的几种方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e7%94%a8%e6%88%b7%e6%80%81%e5%92%8c%e5%86%85%e6%a0%b8%e6%80%81%e4%ba%a4%e4%ba%92%e7%9a%84%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img2.baidu.com/it/u=408265743,2883498083&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=PNG?w=522&amp;amp;h=500&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;分为内核态&lt;code&gt;Kernel Mode&lt;/code&gt;和用户态&lt;code&gt;User Mode&lt;/code&gt;，&lt;strong&gt;其通信方式主要有&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;系统调用&lt;code&gt;System Call&lt;/code&gt;&lt;/strong&gt;：最常见的用户态和内核态之间的通信方式。通过系统调用接口（&lt;code&gt;open&lt;/code&gt;、&lt;code&gt;read&lt;/code&gt;、&lt;code&gt;write&lt;/code&gt;、&lt;code&gt;fork&lt;/code&gt;等）请求内核执行特定的动作。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;中断&lt;code&gt;Interrupts&lt;/code&gt;&lt;/strong&gt;：中断包括软中断和硬中断，每当中断到来的时候，&lt;code&gt;CPU&lt;/code&gt;会暂停当前执行的用户态代码，切换到内核态来处理中断。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;信号&lt;code&gt;Signal&lt;/code&gt;&lt;/strong&gt;：内核通过&lt;code&gt;Signal&lt;/code&gt;通知用户态进程发生了某些事件，用户态注册信号处理函数，来响应特定的信号事件。如 &lt;code&gt;SIGTERM&lt;/code&gt;、&lt;code&gt;SIGINT&lt;/code&gt; 等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;共享内存&lt;code&gt;Share Memory&lt;/code&gt;&lt;/strong&gt;：允许多个进程在它们的地址空间中共享一块内存区域，从而实现用户态和内核态之间的高效通信。这种方式避免了用户态和内核态之间频繁切换的问题，但是也需要考虑到数据的同步问题，保证数据一致性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img0.baidu.com/it/u=4155245835,2490995974&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=PNG?w=598&amp;amp;h=327&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;用户态&lt;code&gt;User Mode&lt;/code&gt;访问内核态&lt;code&gt;Kernel Mode&lt;/code&gt;的&lt;strong&gt;数据交互的方式有&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;procfs&lt;/code&gt;进程文件系统&lt;/strong&gt;：一个伪文件系统，因为其不占用外部存储空间，只占有少量的内存，挂载在&lt;code&gt;/proc&lt;/code&gt;目录下&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;sysctl&lt;/code&gt;&lt;/strong&gt;：它也是一个&lt;code&gt;Linux&lt;/code&gt;命令，主要用来修改内核的运行时参数，也就是在内核运行时，动态修改内核参数。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;和 &lt;code&gt;procfs&lt;/code&gt; 的区别在于：&lt;code&gt;procfs&lt;/code&gt; 主要是输出只读数据，而 &lt;code&gt;sysctl&lt;/code&gt; 输出的大部分信息是可写的。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;sysfs&lt;/code&gt;虚拟文件系统&lt;/strong&gt;：通过&lt;code&gt;/sys&lt;/code&gt;来完成用户态和内核的通信，和 procfs 不同的是，sysfs 是将一些原本在 procfs 中的，关于设备和驱动的部分，独立出来，以 “设备树” 的形式呈现给用户。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;netlink &lt;/code&gt;接口&lt;/strong&gt;：也是最常用的一种方式，本质是&lt;code&gt;socket&lt;/code&gt;接口，使用&lt;code&gt;netlink&lt;/code&gt;用于网络相关的内核和用户进程之间的消息传递。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;共享内存&lt;code&gt;Share Memory&lt;/code&gt;&lt;/strong&gt;：允许多个进程在它们的地址空间中共享一块内存区域，从而实现用户态和内核态之间的高效数据传输。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;center&gt;&lt;b&gt; &lt;font color =&#34;blue&#34;&gt;欢迎关注【嵌入式艺术】，董哥原创！&lt;/font&gt;&lt;/b&gt;&lt;/center&gt;&#xA;&lt;div align=center&gt;&lt;img src=&#34;https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/blog.png&#34; alt=&#34;img&#34; width = &#34;60%&#34; height =&#34;10%&#34;/&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
